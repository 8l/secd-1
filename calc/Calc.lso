dnl --- Simple Calculator
(LETREC TEST
  (TEST LAMBDA (EXPR)
    (EVAL (CFGPARSE
      (MAPFROMLIST ExpressionCFG)
      (MAPFROMLIST ExpressionDFA)
      (LAMBDA (TOKEN) (IF (NUMBER TOKEN) (QUOTE ID) TOKEN))
      (LAMBDA (TOKEN) (STOP (CONS (QUOTE ParseError) TOKEN)))
      (FLATTEN EXPR))))

  dnl --- Flattens the list, turning the beginning and end of sub-lists
  dnl     into OPENP & CLOSEP tokens, respectively.
  (FLATTEN LAMBDA (L)
    (LETREC
      (FLATTENCC L (QUOTE NIL))
      (FLATTENCC LAMBDA (L CC)
        (IF (ISNIL L)
            (REVERSE CC)
        (IF (ATOM (CAR L))
            (FLATTENCC (CDR L) (CONS (CAR L) CC))
            (FLATTENCC
              (APPEND
                (CONS (QUOTE OPENP) (CAR L))
                (CONS (QUOTE CLOSEP) (CDR L)))
              CC))))))

  dnl --- Recursively descend into the parse tree using pattern matching,
  dnl     evaluating the expressions as we ascend.
  (EVAL LAMBDA (TREE) (LET
    (MATCH TREE
      (CASE ((C.*) _ < _)     (BINOP LT))
      (CASE ((C.*) _ > _)     (BINOP GT))
      (CASE ((C.*) _ <= _)    (BINOP LEQ))
      (CASE ((C.*) _ >= _)    (BINOP GEQ))
      (CASE ((C.*) _ == _)    (BINOP EQ))
      (CASE ((C.*) _ != _)    (BINOP NEQ))
      (CASE ((E.*) _ + _)     (BINOP ADD))
      (CASE ((E.*) _ - _)     (BINOP SUB))
      (CASE ((T.*) _ (\ *) _) (BINOP MUL))
      (CASE ((T.*) _ / _)     (BINOP DIV))
      (CASE ((F.*) * _ *)     (EVAL _1))
      (CASE ((F.*) _)         _1)
      (CASE ((*.*) _)         (EVAL _1))
      (CASE _                 (STOP (LIST (QUOTE UnexpectedError) _1))))
    (BINOP MACRO (OP) (OP (EVAL _1) (EVAL _2)))))

  (ExpressionCFG QUOTE
include(ExpressionCFG.lso)
    )

  (ExpressionDFA QUOTE
include(ExpressionDFA.lso)
    )

include(Cfg.lso)
include(Util.lso)
include(Pattern.lso)

  )
