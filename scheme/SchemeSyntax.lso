dnl  ===========================================================================
dnl | Grammar for Scheme (R5RS) syntax
dnl |
dnl | See http://www.schemers.org/Documents/Standards/R5RS for details
dnl |
dnl | The following grammar is structured as a list of items of the form:
dnl |
dnl |   (<non-terminal> (<right-hand-side-1>) (<right-hand-side-2>) ... ), or
dnl |   (<terminal>)
dnl |
dnl | where <non-terminal> is a non-terminal symbol, and is followed by a list
dnl | one or more production rules for that symbol, or where <terminal> is a
dnl | terminal symbol, and thus has no production rules.  Each production rule
dnl | <right-hand-side-#> is a list of the symbols on the right hand side of the
dnl | production rule.  The production rule NIL denotes a production of the form
dnl |
dnl |   <non-terminal>  -->  <empty-string>
dnl |
dnl | There is a special non-terminal symbol "START" which must have exactly one
dnl | production rule.
dnl  ===========================================================================
ifdef(`scheme_syntax_lso_m4',,`define(`scheme_syntax_lso_m4',1)dnl

(SchemeGrammar MACRO NIL (LIST

dnl  ---------------------------------------------------------------------------
dnl | Root Production Rule
dnl  ---------------------------------------------------------------------------

  (: START (=> (Program)))



dnl  ---------------------------------------------------------------------------
dnl | Helper Rules
dnl  ---------------------------------------------------------------------------

  (: Identifier*
    (=> NIL)
    (=> (Identifier* IDENT)))
  (: Variable*
    (=> NIL)
    (=>1 (Variable+)))
  (: Variable+
    (=>1 (VARIABLE))
    (=> (Variable+ VARIABLE)))



dnl  ---------------------------------------------------------------------------
dnl | Terminals
dnl  ---------------------------------------------------------------------------

  (: AND)
  (: ARROW)
  (: BACKQUOTE)
  (: BEGIN)
  (: BOOL)
  (: CASE)
  (: CHAR)
  (: CLOSEP)
  (: COMMA)
  (: COMMAAT)
  (: COND)
  (: DEFINE)
  (: DEFINESYNTAX)
  (: DELAY)
  (: DO)
  (: DOT)
  (: ELLIPSIS)
  (: ELSE)
  (: IDENT)
  (: IF)
  (: KEYWORD)
  (: KEYWORDQUOTE)
  (: LAMBDA)
  (: LET)
  (: LETREC)
  (: LETRECSYNTAX)
  (: LETSTAR)
  (: LETSYNTAX)
  (: NUMBER)
  (: OPENP)
  (: OPENVEC)
  (: OR)
  (: QUOTE)
  (: SETBANG)
  (: STRING)
  (: SYNTAXRULES)
  (: VARIABLE)



dnl  ---------------------------------------------------------------------------
dnl | 7.1.2  External Representations
dnl  ---------------------------------------------------------------------------

  (: Datum
    (=>1 (SimpleDatum))
    (=>1 (CompoundDatum)))
  (: Datum*
    (=> NIL)
    (=>1 (Datum+)))
  (: Datum+
    (=>1 (Datum))
    (=> (Datum+ Datum)))
  (: SimpleDatum
    (=>1 (BOOL))
    (=>1 (NUMBER))
    (=>1 (CHAR))
    (=>1 (STRING))
    (=>1 (Symbol)))
  (: Symbol
    (=>1 (VARIABLE)))
  (: CompoundDatum
    (=>1 (List))
    (=>1 (Vector)))
  (: List
    (=> (OPENP Datum* CLOSEP))
    (=> (OPENP Datum+ DOT Datum CLOSEP))
    (=>1 (Abbreviation)))
  (: Abbreviation
    (=> (AbbrevPrefix Datum)))
  (: AbbrevPrefix
    (=>1 (QUOTE))
    (=>1 (BACKQUOTE))
    (=>1 (COMMA))
    (=>1 (COMMAAT)))
  (: Vector
    (=> (OPENVEC Datum* CLOSEP)))



dnl  ---------------------------------------------------------------------------
dnl | 7.1.3  Expressions
dnl  ---------------------------------------------------------------------------

  (: Expression
    (=>1 (VARIABLE))
    (=>1 (Literal))
    (=>1 (ProcedureCall))
    (=>1 (LambdaExpression))
    (=>1 (Conditional))
    (=>1 (Assignment))
    (=>1 (DerivedExpression))
    (=>1 (MacroUse))
    (=>1 (MacroBlock)))
  (: Literal
    (=>1 (Quotation))
    (=>1 (SelfEvaluating)))
  (: SelfEvaluating
    (=>1 (BOOL))
    (=>1 (NUMBER))
    (=>1 (CHAR))
    (=>1 (STRING)))
  (: Quotation
    (=> (QUOTE Datum))
    (=> (OPENP KEYWORDQUOTE Datum CLOSEP)))
  (: ProcedureCall
    (=> (OPENP Operator Operand+ CLOSEP))
    (=> (OPENP Operator CLOSEP)))
  (: Operator
    (=>1 (Expression)))
  (: Operand
    (=>1 (Expression)))
  (: Operand*
    (=> NIL)
    (=> (Operand* Operand)))
  (: Operand+
    (=>1 (Operand))
    (=> (Operand+ Operand)))
  (: LambdaExpression
    (=> (OPENP LAMBDA Formals Body CLOSEP)))
  (: Formals
    (=> (OPENP Variable* CLOSEP))
    (=>1 (VARIABLE))
    (=> (OPENP Variable+ DOT VARIABLE CLOSEP)))
  (: Body
    (=> (Definition* Sequence)))
  (: Sequence
    (=>1 (Expression))
    (=> (Command+ Expression)))
  (: Command
    (=>1 (Expression)))
  (: Command*
    (=> NIL)
    (=> (Command* Command)))
  (: Command+
    (=>1 (Command))
    (=> (Command+ Command)))
  (: Conditional
    (=> (OPENP IF Test Consequent Alternate CLOSEP)))
  (: Test
    (=>1 (Expression)))
  (: Consequent
    (=>1 (Expression)))
  (: Alternate
    (=>1 (Expression))
    (=> NIL))
  (: Assignment
    (=> (OPENP SETBANG VARIABLE Expression CLOSEP)))
  (: DerivedExpression
    (=> (OPENP COND CondClause+ CLOSEP))
    (=> (OPENP COND CondClause+ OPENP ELSE Sequence CLOSEP CLOSEP))
    (=> (OPENP COND OPENP ELSE Sequence CLOSEP CLOSEP))
    (=> (OPENP CASE Expression CaseClause+ CLOSEP))
    (=> (OPENP CASE Expression CaseClause+ OPENP ELSE Sequence CLOSEP CLOSEP))
    (=> (OPENP CASE Expression OPENP ELSE Sequence CLOSEP CLOSEP))
    (=> (OPENP AND Test* CLOSEP))
    (=> (OPENP OR Test* CLOSEP))
    (=> (OPENP LET OPENP BindingSpec* CLOSEP Body CLOSEP))
    (=> (OPENP LET VARIABLE OPENP BindingSpec* CLOSEP Body CLOSEP))
    (=> (OPENP LETSTAR OPENP BindingSpec* CLOSEP Body CLOSEP))
    (=> (OPENP LETREC OPENP BindingSpec* CLOSEP Body CLOSEP))
    (=> (OPENP BEGIN Sequence CLOSEP))
    (=> (OPENP DO OPENP IterationSpec* CLOSEP OPENP Test DoResult CLOSEP Sequence CLOSEP))
    (=> (OPENP DO OPENP IterationSpec* CLOSEP OPENP Test DoResult CLOSEP CLOSEP))
    (=> (OPENP DELAY Expression CLOSEP)))
  (: CondClause
    (=> (OPENP Test Sequence CLOSEP))
    (=> (OPENP Test CLOSEP))
    (=> (OPENP Test ARROW Recipient CLOSEP)))
  (: CondClause*
    (=> NIL)
    (=> (CondClause* CondClause)))
  (: CondClause+
    (=>1 (CondClause))
    (=> (CondClause+ CondClause)))
  (: Recipient
    (=>1 (Expression)))
  (: CaseClause
    (=> (OPENP OPENP Datum* CLOSEP Sequence CLOSEP)))
  (: BindingSpec
    (=> (OPENP VARIABLE Expression CLOSEP)))
  (: IterationSpec
    (=> (OPENP VARIABLE Init Step CLOSEP))
    (=> (OPENP VARIABLE Init CLOSEP)))
  (: Init
    (=>1 (Expression)))
  (: Step
    (=>1 (Expression)))
  (: DoResult
    (=>1 (Sequence))
    (=> NIL))
  (: MacroUse
    (=> (OPENP Keyword Datum* CLOSEP)))
  (: Keyword
    (=> (IDENT)))
  (: MacroBlock
    (=> (OPENP LETSYNTAX OPENP SyntaxSpec* CLOSEP Body CLOSEP))
    (=> (OPENP LETRECSYNTAX OPENP SyntaxSpec* CLOSEP Body CLOSEP)))
  (: SyntaxSpec
    (=> (OPENP Keyword TransformerSpec CLOSEP)))



dnl  ---------------------------------------------------------------------------
dnl | 7.1.5  Transformers
dnl  ---------------------------------------------------------------------------

  (: TransformerSpec
    (=> (OPENP SYNTAXRULES OPENP Identifier* CLOSEP SyntaxRule* CLOSEP)))
  (: SyntaxRule
    (=> (OPENP Pattern Template CLOSEP)))
  (: SyntaxRule*
    (=> NIL)
    (=> (SyntaxRule* SyntaxRule)))
  (: Pattern
    (=>1 (PatternIdentifier))
    (=> (OPENP Pattern* CLOSEP))
    (=> (OPENP Pattern+ DOT Pattern CLOSEP))
    (=> (OPENP Pattern+ ELLIPSIS CLOSEP))
    (=> (OPENVEC Pattern* CLOSEP))
    (=> (OPENVEC Pattern+ ELLIPSIS CLOSEP))
    (=>1 (PatternDatum)))
  (: Pattern*
    (=> NIL)
    (=>1 (Pattern+)))
  (: Pattern+
    (=>1 (Pattern))
    (=> (Pattern+ Pattern)))
  (: PatternDatum
    (=>1 (STRING))
    (=>1 (CHAR))
    (=>1 (BOOL))
    (=>1 (NUMBER)))
  (: Template
    (=>1 (PatternIdentifier))
    (=> (OPENP TemplateElement* CLOSEP))
    (=> (OPENP TemplateElement+ DOT Template CLOSEP))
    (=> (OPENVEC TemplateElement* CLOSEP))
    (=>1 (TemplateDatum)))
  (: TemplateElement
    (=>1 (Template))
    (=> (Template ELLIPSIS)))
  (: TemplateElement*
    (=> NIL)
    (=>1 (TemplateElement+)))
  (: TemplateElement+
    (=>1 (TemplateElement))
    (=> (TemplateElement+ TemplateElement)))
  (: TemplateDatum
    (=>1 (PatternDatum)))
  (: PatternIdentifier
    (=>1 (VARIABLE)))         dnl --- TODO: Should accept any identifier except "..."



dnl  ---------------------------------------------------------------------------
dnl | 7.1.6  Programs and Definitions
dnl  ---------------------------------------------------------------------------

  (: Program (=> (CommandOrDefinition*)))
  (: CommandOrDefinition
    (=>1 (Command))
    (=>1 (Definition))
    (=>1 (SyntaxDefinition)))
dnl    (=> (OPENP BEGIN CommandAndDefinition+ CLOSEP)))
        dnl ^-- This production rule causes inherent ambiguities in the Scheme
        dnl     grammar, since (OPENP BEGIN Definition+ CLOSEP) and
        dnl     (OPENP BEGIN Command+ CLOSEP) are both accounted for by
        dnl     production rules for "Definition" and for "DerivedExpression",
        dnl     respectively.  This rule essentially serves as a catch-all for
        dnl     (OPENP BEGIN ... CLOSEP) blocks which either contain syntax
        dnl     definitions or contain BOTH commands AND definitions.  Until we
        dnl     can implement a proper solution for this case, I am leaving this
        dnl     production rule out.
  (: CommandOrDefinition*
    (=> NIL)
    (=>1 (CommandOrDefinition+)))
  (: CommandOrDefinition+
    (=>1 (CommandOrDefinition))
    (=> (CommandOrDefinition+ CommandOrDefinition)))
  (: Definition
    (=> (OPENP DEFINE VARIABLE Expression CLOSEP))
    (=> (OPENP DEFINE OPENP DefFormals CLOSEP Body CLOSEP))
    (=> (OPENP BEGIN Definition+ CLOSEP)))
  (: Definition*
    (=> NIL)
    (=> (Definition* Definition)))
  (: Definition+
    (=>1 (Definition))
    (=> (Definition+ Definition)))
  (: DefFormals
    (=> (Variable+))
    (=> (Variable+ DOT VARIABLE)))
  (: SyntaxDefinition
    (=> (OPENP DEFINESYNTAX IDENT TransformerSpec CLOSEP)))
  (: CaseClause*
    (=> NIL)
    (=>1 (CaseClause+)))
  (: CaseClause+
    (=>1 (CaseClause))
    (=> (CaseClause+ CaseClause)))
  (: BindingSpec*
    (=> NIL)
    (=> (BindingSpec* BindingSpec)))
  (: IterationSpec*
    (=> NIL)
    (=> (IterationSpec* IterationSpec)))
  (: SyntaxSpec*
    (=> NIL)
    (=> (SyntaxSpec* SyntaxSpec)))
  (: Test*
    (=> NIL)
    (=> (Test* Test)))
dnl  ---------------------------------------------------------------------------
  ))

')dnl
